#include <pthread.h>
#include <signal.h>
#include <stdio.h>
#include <sys/neutrino.h>
#include <stdlib.h>
#include "fifo.h"
#include <process.h>
#include"IPC.h"

void *send(void *data) {
	int serverPID = 0, chid = 0; 	// Server PID and channel ID

	serverPID = getpid(); 		// get server process ID

	printf("%i\n", serverPID);

	// Create Channel
		chid = ChannelCreate(_NTO_CHF_DISCONNECT);
		printf("%i\n",chid);
		Write_Server_INFO(serverPID,chid);
		my_data msg;
		int rcvid=0, msgnum=0;  	// no message received yet
		int Stay_alive=1, living=0;	// server stays running (ignores _PULSE_CODE_DISCONNECT request)

		my_reply replymsg; 			// replymsg structure for sending back to client
		replymsg.hdr.type = 0x01;
		replymsg.hdr.subtype = 0x00;
		living =1;
			while (living)
			{
				 // Do your MsgReceive's here now with the chid
				 rcvid = MsgReceive(chid, &msg, sizeof(msg), NULL);
				 printf("%d",rcvid);
				 if (rcvid == -1)  // Error condition, exit
					   {
						   printf("\nFailed to MsgReceive\n");
						   break;
					   }
				 if (rcvid == 0)  //  Pulse received, work out what type
					   {
						   switch (msg.hdr.code)
						   {
							   case _PULSE_CODE_DISCONNECT:
									// A client disconnected all its connections by running
									// name_close() for each name_open()  or terminated
								   if( Stay_alive == 0)
								   {
									   ConnectDetach(msg.hdr.scoid);
									   printf("\nServer was told to Detach from ClientID:%d ...\n", msg.ClientID);
									   living = 0; // kill while loop
									   continue;
								   }
								   else
								   {
									   printf("\nServer received Detach pulse from ClientID:%d but rejected it ...\n", msg.ClientID);
								   }
								   break;

							   case _PULSE_CODE_UNBLOCK:
									// REPLY blocked client wants to unblock (was hit by a signal
									// or timed out).  It's up to you if you reply now or later.
								   printf("\nServer got _PULSE_CODE_UNBLOCK after %d, msgnum\n", msgnum);
								   break;
							   case _PULSE_CODE_COIDDEATH:  // from the kernel
								   printf("\nServer got _PULSE_CODE_COIDDEATH after %d, msgnum\n", msgnum);
								   break;
							   case _PULSE_CODE_THREADDEATH: // from the kernel
								   printf("\nServer got _PULSE_CODE_THREADDEATH after %d, msgnum\n", msgnum);
								   break;
							   default:
								   // Some other pulse sent by one of your processes or the kernel
								   printf("\nServer got some other pulse after %d, msgnum\n", msgnum);
								   break;

						   }
						   continue;// go back to top of while loop
					   }
				   if(rcvid > 0) // if true then A message was received
				   {
			       if(msg.data==2){
			         Stay_alive=0;
			       }

					   msgnum++;

					   // If the Global Name Service (gns) is running, name_open() sends a connect message. The server must EOK it.
					   if (msg.hdr.type == _IO_CONNECT )
					   {
						   MsgReply( rcvid, EOK, NULL, 0 );
						   printf("\n gns service is running....");
						   continue;	// go back to top of while loop
					   }

					   // Some other I/O message was received; reject it
					   if (msg.hdr.type > _IO_BASE && msg.hdr.type <= _IO_MAX )
					   {
						   MsgError( rcvid, ENOSYS );
						   printf("\n Server received and IO message and rejected it....");
						   continue;	// go back to top of while loop
					   }

					   // A message (presumably ours) received

					   // put your message handling code here and assemble a reply message
					   sprintf(replymsg.buf, "Message %d received", msgnum);
					   printf("Server received data packet with value of '%d' from client (ID:%d), \n", msg.data, msg.ClientID);
						   fflush(stdout);
						  // sleep(1); // Delay the reply by a second (just for demonstration purposes)

					   printf("\n    -----> replying with: '%s'\n",replymsg.buf);
					   MsgReply(rcvid, EOK, &replymsg, sizeof(replymsg));
				   }
				   else
				  {
				printf("\nERROR: Server received something, but could not handle it correctly\n");
				  }

			}


			printf("\nServer received Destroy command\n");
			// destroyed channel before exiting
			ChannelDestroy(chid);
	return NULL;
}

void *send(void *data) {


}
}




